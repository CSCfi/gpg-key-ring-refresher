#!/usr/bin/perl
#
# GPG key ring refresher for autonomous updating of big public key rings.
#
# Author: Mika Silander
#
# Copyright (C) 2020 CSC - IT Centre for Science Ltd, www.csc.fi
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

use strict;
use Getopt::Std;
use POSIX ":sys_wait_h";
use Log::Log4perl qw(:levels get_logger);
use Digest::MD5 qw(md5_hex md5_base64);


package KeySignatureLimits;

# A max_signatures set to zero means there are no limits, same applies
# to max_signatures_on_refresh. Obviously something not to recommend.
sub new {
    my ($class, $id, $max_total, $max_refresh) = @_;

    return undef if ($id !~ /^[a-f\d]{16}$/io);
    return undef if ($max_total !~ /^\d+$/o);
    return undef if ($max_refresh !~ /^\d+$/o);

    my $self = {
	'id' => uc($id),
	'max_signatures' => $max_total,
	'max_signatures_on_refresh' => $max_refresh
    };

    bless $self, $class;
}

sub getLimits {
    ($_[0]->{'max_signatures'}, $_[0]->{'max_signatures_on_refresh'});
}


package Key;

# All possible key statuses
use constant {
    NOT_SEARCHED_FOR => 0,
    SEARCHED_FOR_BUT_NOT_FOUND => 1,
    UNCHANGED => 2,
    CHANGED_SIGN_LIMIT_NOT_EXCEEDED => 3,
    CHANGED_SIGN_LIMIT_EXCEEDED => 4,
    SIGN_LIMIT_EXCEEDED => 5,
    ON_PRESKIPLIST => 6,
    REVOKED => 7,
    EXPIRED => 8
};

our $logger = Log::Log4perl::get_logger(__PACKAGE__);

sub new {
    my ($class, $id, $num_signatures) = @_;
    my $self = {
	'id' => $id,
	'tried_keyservers' => {},
	'num_signatures' => $num_signatures || 0,
	'max_new_signatures' => 0,
        'status' => NOT_SEARCHED_FOR
    };

    bless $self, $class;
}

sub getId {
    $_[0]->{'id'};
}

sub getTriedKeyServers {
    $_[0]->{'tried_keyservers'};
}

sub addSourceKeyServer {
    my ($self, $sourceservername) = @_;
    ${$self->{'tried_keyservers'}}{$sourceservername} = 1;
}

sub addTriedKeyServer {
    my ($self, $triedservername) = @_;
    ${$self->{'tried_keyservers'}}{$triedservername} = 0;
}

sub getTryCount {
    scalar(keys %{$_[0]->{'tried_keyservers'}});
}

# see constants above
sub getStatus {
    $_[0]->{'status'};
}

sub setStatus {
    my ($self, $status) = @_;
    $logger->fatal("Illegal key status $status") if ($status !~ /^[0-8]$/o);
    $self->{'status'} = $status;
}

sub eligible {
    my ($self, $servername) = @_;
    return 1 if ($self->{'status'} == NOT_SEARCHED_FOR);
    return 1 if (($self->{'status'} == SEARCHED_FOR_BUT_NOT_FOUND) and
		 (!exists ${$self->{'tried_keyservers'}}{$servername}));
    0;
}

sub getNumSignatures {
    $_[0]->{'num_signatures'};
}

sub setMaxNewSignatures {
    my ($self, $numnewsigs) = @_;
    ${$self}{'max_new_signatures'} = $numnewsigs;
}

sub getMaxNewSignatures {
    $_[0]->{'max_new_signatures'};
}

sub isNumNewSignaturesOk {
    my ($self, $numsigs) = @_;

    my $mns = $self->getMaxNewSignatures();
    return 1 if ($numsigs <= $mns);
    return 1 if ($mns == -1); # -1 means no limits on number of new sigs 
    0;
}

sub addNewSignatures {
    my ($self, $numsigs) = @_;
    $self->{'num_signatures'} += $numsigs;
}

sub stats {
    my $self = shift;
    my ($servername, $hit, $msg);

    # maps back to the Key::* constants
    my @statusmap = (
	"NOT_SEARCHED_FOR",
	"NOT FOUND",
	"UNCHANGED",
	"CHANGED, SIGS OK",
	"UNCHANGED, TOO MANY SIGS",
	"SIGN LIMIT EXCEEDED",
	"ON PRESKIPLIST",
	"REVOKED",
	"EXPIRED"
	);

    $hit = undef;
    if ($self->getStatus() > SEARCHED_FOR_BUT_NOT_FOUND) {
	while (($servername, $hit) = each %{$self->{'tried_keyservers'}}) {
	    last if $hit;
	}
    }

    $msg = " $self->{'id'}, sigs(" . $self->{'num_signatures'} .
	") (" . lc($statusmap[$self->{'status'}]) . "/tries " .
	$self->getTryCount() . (defined $hit ? "/source $servername)" : ")");

    $logger->is_warn() ? $logger->warn($msg) : $logger->info($msg);
}


package KeyIdBookie;

our $logger = Log::Log4perl::get_logger(__PACKAGE__);

sub new {
    my ($class, $keys, $max_retries, $chunksize) = @_;
    my $self;
    
    $self = {
	'not_found_keys' => $keys,
	'unchanged_keys' => {},
        'changed_keys_sigs_ok' => {},
        'changed_keys_sigs_not_ok' => {},
	'max_retries' => $max_retries, # set to number of key servers configured
        'chunksize' => $chunksize,
    };
    
    bless $self, $class;
}

sub _getKeyChunkForServer {
    my ($self, $server) = @_;
    my $servername = $server->getName();
    my $nf = $self->{'not_found_keys'};

    my @bloodyexperimentalspliceonscalarforbidden =
	sort _keytrycountcmp (grep { $_->getTryCount() < $self->{'max_retries'} } (grep { $_->eligible($servername) } values %{$nf}));

    # return chunksize elements of least fetched Keys
    (splice (@bloodyexperimentalspliceonscalarforbidden, 0, $self->{'chunksize'}));
}

sub _keytrycountcmp {
    $a->getTryCount() <=> $b->getTryCount();
}

# Return max_chunksize of the least fetched keys to be refreshed from
# the given key server.
sub keyChunkToRefreshFromServer {
    my ($self, @orderedServers) = @_;
    my @keylist = ();
    my $s;

    for $s (@orderedServers) {
	@keylist = $self->_getKeyChunkForServer($s);
        return ( [ @keylist ], $s) if (@keylist);
    }
    ( [], undef );
}

sub recordKeyInfo {
    my ($self, $server, $not_changed_r, $changed_sigs_ok_r,
	$changed_sigs_not_ok_r, $not_found_due_to_refresh_failure_r,
	$refreshed_but_not_found_r) = @_;

    $server = $server->getName();
    $self->addUnchangedKeys($server, $not_changed_r);
    $self->addChangedKeysSigsOk($server, $changed_sigs_ok_r);
    $self->addChangedKeysTooManySigs($server, $changed_sigs_not_ok_r);
    # we simply ignore these: $not_found_due_to_refresh_failure_r
    $self->refreshedButNotFoundKeys($server, $refreshed_but_not_found_r);
}

sub _categoriseKeys {
    my ($self, $servername, $idlist, $targetkeylist) = @_;
    my ($key, $id);
    my $nf = $self->{'not_found_keys'};
    my $t = $self->{$targetkeylist};

    for $id (@{$idlist}) {
	# store the server we found the key data from and
	# move key to the unchanged ones
	$key = $nf->{$id};
	$key->addSourceKeyServer($servername);
	$t->{$id} = $key;
	# remove from not found key ids
	delete $nf->{$id};
    }
}

sub addUnchangedKeys {
    my ($self, $servername, $idlist) = @_;
    $self->_categoriseKeys($servername, $idlist, 'unchanged_keys');
}

sub addChangedKeysSigsOk {
    my ($self, $servername, $idlist) = @_;
    $self->_categoriseKeys($servername, $idlist, 'changed_keys_sigs_ok');
}

sub addChangedKeysTooManySigs {
    my ($self, $servername, $idlist) = @_;
    $self->_categoriseKeys($servername, $idlist, 'changed_keys_sigs_not_ok');
}

sub refreshedButNotFoundKeys {
    my ($self, $servername, $idlist) = @_;
    my ($key, $id);
    my $nf = $self->{'not_found_keys'};

    for $id (@{$idlist}) {
	# We remember the server that was unable to provide info on this key.
	$key = $nf->{$id};
	$key->addTriedKeyServer($servername);
	$key->setStatus(Key::SEARCHED_FOR_BUT_NOT_FOUND);
    }
}

sub getStatus {
    my $self = shift;
    my $status = 0;
    $status = 36 if (keys %{$self->{'changed_keys_sigs_not_ok'}});
    $status = 37 if (keys %{$self->{'not_found_keys'}});
    $status;
}

sub stats {
    my $self = shift;
    my ($s, $numkeys, $id, $m);
    my @o = ();

    for $s ( ['unchanged keys', 'unchanged_keys', undef, $Log::Log4perl::INFO ],
	     ['changed keys adhering to signature limits', 'changed_keys_sigs_ok',
	      undef, $Log::Log4perl::INFO ],
	     ['changed keys exceeding signature limits', 'changed_keys_sigs_not_ok',
	      [ "Adjust global key signature limits,",
		"set key specific signature limits, or,",
		"move the key to the preskip list:" ],
	      $Log::Log4perl::WARN
	     ],
	     ['keys not found', 'not_found_keys',
	      [ "Add keys not found to the preskip list,",
		"ask their owners to upload them, or, configure",
		"new key servers that can provide info about them:" ],
	      $Log::Log4perl::WARN
	     ] ) {
	@o =(@{$s});
	$numkeys = keys %{$self->{$o[1]}};
	$logger->log( ($numkeys ? $o[3] : $Log::Log4perl::INFO),
		      "Number of $o[0] : $numkeys");
	next if (!$numkeys);

	if ($logger->is_debug() or (defined $o[2])) {
	    foreach $m (@{$o[2]}) { $logger->log($o[3], " $m"); }
	    foreach $id (sort keys %{$self->{$o[1]}}) {
		$self->{$o[1]}->{$id}->stats();
	    }
	}
    }
}


package KeyServer;

our $logger = Log::Log4perl::get_logger(__PACKAGE__);

sub new {
    my ($class, $servername, $max_num_consecutively_failed_requests,
	$max_refr_wait_secs) = @_;
    my $self = {
	'name' => $servername,
    	'max_num_consecutively_failed_requests' => $max_num_consecutively_failed_requests,
	'quality' => 4, # guarantees all configured servers are tried at least once
	'num_requests_initiated' => 0,
	'num_requests_failed' => 0,
	'num_requests_partial' => 0,
	'num_requests_successful' => 0,
	'keys_retrieved' => 0,
	'keys_not_found' => 0,
	'last_refresh_attempt_killed' => 0,
	'working_dir_updated_in_last_refresh' => 0,
	'max_refresh_wait_secs' => (defined $max_refr_wait_secs ? $max_refr_wait_secs : 240),
	'consecutive_failure_count' => 0,
	'prev_request_status' => "ok" # ok or failure    
    };
    
    bless $self, $class;
}

sub eligible {
    my $self = shift;

    return 1 if ($self->{'max_num_consecutively_failed_requests'} >
		 $self->{'consecutive_failure_count'});
    0;
}

sub getName {
    $_[0]->{'name'};
}

sub getQuality {
    $_[0]->{'quality'};
    # see updating of quality from the end of the method _updateKeyServerState.
}

sub attemptKeyUpdate {
    my ($self, $gpgcmd, $gnupgworkdir, $gpgrefreshoutputfile, @keys) = @_;
    my ($pid, $starttime, $sleeptime);
    my ($status, $iwaited);
    my $maxwaitsecs = $self->{'max_refresh_wait_secs'};
    my $keyinfo;
    my ($killcount, $killrounds);
    
    if ($pid = fork()) {
	# parent
	${$self}{'num_requests_initiated'} += 1;
	$self->{'last_refresh_attempt_killed'} = 0;
	$self->{'working_dir_updated_in_last_refresh'} = 0;

	$starttime = time();
	$iwaited = 0;
	while ((! -e "$gpgrefreshoutputfile") &&
	       (time() - $starttime < $maxwaitsecs)) {
	    # wait 2 seconds before each check that the gpg refresh process
	    # has truly started
            sleep 2;
	}
	
	if (! -e "$gpgrefreshoutputfile") {
	    $logger->fatal("gpg refresh subprocess failed to start successfully");
	    return ("", 5);
	}

	$status = 1;
	while (time() - $starttime < $maxwaitsecs && ($status > 0)) {
	    # wait 5 seconds before each check of gpg refresh subprocess status.
	    $logger->debug("Waiting on child $pid for 5 secs before checking ...");
	    sleep 5;
	    $status = waitpid $pid, 'WNOHANG';
	    $logger->debug("Waited on child $pid (waitpid gave $status)");
	    $iwaited = 1;
	}

	$self->{'last_refresh_attempt_killed'} = 0;
	if ((time() - $starttime >= $maxwaitsecs) or ($status != -1 and $iwaited)) {
            $killrounds = 0;
            do {
		$killcount = kill 'KILL', $pid;
            } while (!$killcount and $killrounds++ < 4);
            $status = waitpid $pid, 'WNOHANG';
            $self->{'last_refresh_attempt_killed'} = 1;
	    if (!$status) {
		# update counters even in the case of a complete failure
		$self->_updateKeyServerState([], [], [], [ @keys ], []);
		$logger->fatal("Failed to kill gpg key refresh process (status $status)");
		return ("", 6);
	    }
	}
	else {
	    $logger->debug("Child $pid terminated successfully");
	}
	
	$logger->debug("Refresh subprocess ",
		       $self->{'last_refresh_attempt_killed'} ? "was killed" : "terminated normally");
	($keyinfo, $status) = $self->_analyseKeyRefreshInfo($gpgrefreshoutputfile, @keys);

	if ($logger->is_debug()) {
	    my $i = 0;
	    my @tki = @{$keyinfo};
	    my $sname = $self->{'name'};
	    for my $type ('Not changed', 'Changed sigs ok',
			  'Changed but sig limit exceeded',
			  'No info given', 'Not seen') {
		if (!@{$tki[$i]}) {
		    $logger->debug("$type : 0 keys");
		}
		else {
		    for my $tkey (@{$tki[$i]}) {
			$logger->debug("$type $tkey on $sname");
		    }
		}
		$i++;
	    }
	}
	
	return ($keyinfo, $status) if ($status);

	# Update the key server's internal counters
	$self->_updateKeyServerState(@{$keyinfo});

	if ($self->{'last_refresh_attempt_killed'}) {
	    return ([$keyinfo->[0], [], $keyinfo->[2], $keyinfo->[3], []], 0);
	}
	else {
	    # Refresh attempt terminated successfully, return the key info found.
	    return ($keyinfo, 0);
	}
    }
    elsif (defined $pid) {
	# child
	my @cmdandargs = (
	    "$gpgcmd", "--homedir", "$gnupgworkdir",
	    "--batch", "--no-tty", "--keyserver-option",
	    "include-revoked,include-subkeys",
	    "--keyserver", "$self->{'name'}", "--refresh-keys",
	    map { $_->getId() } @keys);
	my $cmd = join(" ", @cmdandargs, " 2> $gpgrefreshoutputfile");

	$logger->debug("Starting child $cmd");
	$logger->fatal("Failed to open $gpgrefreshoutputfile")
	    if (!open STDOUT, ">$gpgrefreshoutputfile");
	select STDOUT; $| = 1;
	open STDERR, ">&STDOUT";
	select STDERR; $| = 1;
	$logger->fatal("Child $pid: failed to start $cmd, error $!")
	    if (!exec (@cmdandargs));
	exit(0);
    }
    elsif ($! =~ /No more process/o) {
	# we can retry, but we don't ...
	$logger->fatal("Kernel process table full, forking failed");
	return ("", 7);
    }
    else {
	# fork failure
	$logger->fatal("Failed to fork gpg key ring refresh process");
	return ("", 8);
    }
    
    ("gpg refresh attempt succeeded", 0);
}

sub _analyseKeyRefreshInfo {
    my ($self, $gpgrefreshoutputfile, @keys) = @_;
    my %notchanged = ();
    my %changedsigsok = ();
    my %changedsigsnotok = ();
    my ($line, $prev, $curr, $x, $keyinfo);

    my %allkeys = ( map { ($_->getId() => $_ ); } @keys );
    my %allids = ( map { ( $_->getId() => 0 ); } @keys );

    $curr = undef;
    if (open(REFRFH, "$gpgrefreshoutputfile")) {
	while ($line = <REFRFH>) {
	    if ($line =~ /^gpg:\skey\s(?:0x)?([a-fA-F\d]{16})\:\s\"[^\"]+\"\s(.+)\s*$/o) {
		# we hit an info line
		$curr = $1;
		if ($curr ne $prev) {
		    $x = $allkeys{$curr};
		    delete $allids{$prev} if (defined $prev);
		    $prev = $curr;
		}
		$keyinfo = $2;
		if ($keyinfo =~ /^(\d+)\snew\ssignatures?$/o) {
		    if ($x->isNumNewSignaturesOk($1)) {
			$changedsigsok{$curr} = 1;
			delete $notchanged{$curr};
			$x->setStatus(Key::CHANGED_SIGN_LIMIT_NOT_EXCEEDED);
		    }
		    else {
			$changedsigsnotok{$curr} = 1;
			delete $changedsigsok{$curr};
			delete $notchanged{$curr};
			$x->setStatus(Key::CHANGED_SIGN_LIMIT_EXCEEDED);
			$self->{'last_refresh_attempt_killed'} = 1;
		    }
		    $x->addNewSignatures($1);
		    next;
		}
		elsif ($keyinfo =~ /^.*(?:\d+\snew\ssubkeys?|revocation\scertificates?\sadded|\d+\snew\suser\sIDs?)$/o) {
		    if ($x->getStatus() < Key::UNCHANGED) {
			$changedsigsok{$curr} = 1;
			delete $notchanged{$curr};
			$x->setStatus(Key::CHANGED_SIGN_LIMIT_NOT_EXCEEDED);
		    }
		    $prev = $curr;
		    next;
		}
		elsif ($keyinfo =~ /not changed/o) {
		    if ($x->getStatus() < Key::UNCHANGED) {
			$notchanged{$curr} = 1;
			$x->setStatus(Key::UNCHANGED);
		    }
		    $prev = $curr;
		}
		else {
		    $logger->fatal("Found a new refresh response type :$keyinfo: for $curr");
		    return ("", 9);
		}
	    }
	}
	close(REFRFH);
	delete $allids{$curr} if (defined $curr);

	if ($self->{'last_refresh_attempt_killed'}) {
	    return ([ [ keys %notchanged ],
		      [ ],
		      [ keys %changedsigsnotok ],
		      [ keys %allids ], [ ] ], 0);
	}
	else {
	    return ([ [ keys %notchanged ],
		      [ keys %changedsigsok ],
		      [ ],
		      [ ], [ keys %allids ] ], 0);
	}
    }
    ("Failed to open $gpgrefreshoutputfile", 10);
}

sub _updateKeyServerState {
    my ($self, $not_changed_r, $changed_sigs_ok_r,
	$changed_sigs_not_ok_r,
	$not_found_r,
	$searched_for_but_not_found_r) = @_;

    my @notchanged = (@{$not_changed_r}, @{$changed_sigs_not_ok_r});
    my @changed = @{$changed_sigs_ok_r};
    my @notfound = (@{$not_found_r}, @{$searched_for_but_not_found_r});

    # We record this for knowing if, when and how we can update the
    # master copy (intact) and working key rings.
    if ($self->{'last_refresh_attempt_killed'}) {
	if ((!@notfound) and (!@changed)) {
	    # all keys refreshed had no changes - success
	    $self->{'num_requests_successful'} += 1;
	    $self->{'consecutive_failure_count'} = 0;
	    $self->{'prev_request_status'} = "ok";
	}
	elsif (@notchanged) {
	    # only some keys found where not changed - partial success
	    $self->{'num_requests_partial'} += 1;
	    $self->{'consecutive_failure_count'} = 0;
	    $self->{'prev_request_status'} = "ok";
	}
	else {
	    # not changed count is 0 so we failed completely
	    $self->{'num_requests_failed'} += 1;
	    $self->{'consecutive_failure_count'} += 1;
	    $self->{'prev_request_status'} = "failure";
	}
	$self->{'working_dir_updated_in_last_refresh'} = 0;
	$self->{'keys_retrieved'} += scalar(@notchanged);
	$self->{'keys_not_found'} += (scalar(@changed) + scalar(@notfound));
    }
    else {
	# the gpg refresh finished successfully, the working ring dir
	# is intact
	if ((!@notchanged) and (!@changed)) {
	    # complete failure
	    $self->{'num_requests_failed'} += 1;
	    $self->{'consecutive_failure_count'} += 1;
	    $self->{'prev_request_status'} = "failure";
	}
	elsif (!@notfound) {
	    # Success! We found info on all keys requested.
	    $self->{'num_requests_successful'} += 1;
	    $self->{'consecutive_failure_count'} = 0;
	    $self->{'prev_request_status'} = "ok";
	}
	else {
	    # Partial success
	    $self->{'num_requests_partial'} += 1;
	    $self->{'consecutive_failure_count'} = 0;
	    $self->{'prev_request_status'} = "ok";
	}
	$self->{'working_dir_updated_in_last_refresh'} = 1 if (@changed);
	$self->{'keys_retrieved'} += (scalar(@changed) + scalar(@notchanged));
	$self->{'keys_not_found'} += scalar(@notfound);
    }

    # update key server quality
    $self->{'quality'} =
	$self->{'num_requests_successful'}/$self->{'num_requests_initiated'} +
	$self->{'num_requests_partial'}/$self->{'num_requests_initiated'} +
	$self->{'keys_retrieved'}/($self->{'keys_retrieved'} +
				   $self->{'keys_not_found'});
}

sub isWorkRingDirIntactAfterLastRefresh {
    $_[0]->{'last_refresh_attempt_killed'} == 0;
}
   
sub wasWorkRingDirUpdatedInLastRefresh {
    $_[0]->{'working_dir_updated_in_last_refresh'};
}

sub stats {
    my $self = shift;
    my $f;

    $logger->info("$self->{'name'} provided info on $self->{'keys_retrieved'} keys, reqs (s=$self->{'num_requests_successful'}/p=$self->{'num_requests_partial'}/f=$self->{'num_requests_failed'}/t=$self->{'num_requests_initiated'}) endstate=",
	($self->eligible() ? "responding" : "unresponsive"));
}

		
package KeyServerBookie;

our $logger = Log::Log4perl::get_logger(__PACKAGE__);

sub new {
    my ($class, $servernames, $max_num_consecutively_failed_requests,
	$max_refr_wait_secs) = @_;
    my $self;
    my %keyservers = ();
    my ($s, $ks);
    
    for $s (@{$servernames}) {
	$ks = KeyServer->new($s,
			     $max_num_consecutively_failed_requests,
			     $max_refr_wait_secs);
	$keyservers{$s} = $ks;
    }
    $self = {
	'keyservers' => \%keyservers
    };
    
    bless $self, $class;
}

sub _keyservercmp {
    $b->getQuality() <=> $a->getQuality();
}

sub orderKeyServersBestFirst {
    my $self = shift;
    my @damnexperimentalshiftonscalarforbidden =
	sort _keyservercmp grep { $_->eligible() } values %{$self->{'keyservers'}};
    @damnexperimentalshiftonscalarforbidden;
}

sub stats {
    my $self = shift;
    for my $ks (values %{$self->{'keyservers'}}) {
	$ks->stats();
    }
}


package KeyRingManager;

use Fcntl qw(:DEFAULT :flock);

our $logger = Log::Log4perl::get_logger(__PACKAGE__);

# Store the name of the master GNUPGHOME directory that is going to be
# updated.
sub new {
    my ($class, $masterdir, $temptopdir, $preskips, $signlimits,
	$global_max_sigs_per_key,
	$global_max_new_sigs_per_key,
	$gpgexec, $copyexec) = @_;

    # We cheat here by turning key identifiers into KeySignatureLimits
    # objects. After keys are skipped, the limits can be forgotten.
    my %preskipkeysfromlist = map { ($_ => KeySignatureLimits->new($_, 0, 0)) }
       @{$preskips};
    my %signlimitsfromlist = map { (${$_}[0] => KeySignatureLimits->new(@{$_})) } map { [ split(" ",$_) ] } @{$signlimits};
    
    my $self = {
	'masterringdir' => $masterdir,
        'temptopdir' => $temptopdir,
        'mastercopydir' => "$temptopdir/mastercopy",
        'workringdir' => "$temptopdir/workring",
	'confdpreskiplist' => \%preskipkeysfromlist,
	'signaturelimits' => \%signlimitsfromlist,
	'global_max_sigs' => $global_max_sigs_per_key,
	'global_max_new_sigs' => $global_max_new_sigs_per_key,
	'gpgexecutable' => $gpgexec,
	'copyexecutable' => $copyexec,
        'files_to_manage' => { 'pubring.kbx' => undef,
			       'trustdb.gpg' => undef },
        'pidfilehandle' => undef,
        'skip_tempdir_deletion' => 0,
	'successfulupdates' => 0,
	'active_keys' => {},
	'preskipped_keys' => {},
	'revoked_keys' => {},
	'expired_keys' => {},
        'signatures_exceeded_keys' => {},
	'processed_sign_limits' => {},
	'total_num_key_ids' => 0
    };

    bless $self, $class;
}

# Create temporary directories, create a master copy and work ring
# GNUPGHOME directory from the master ring that is going to be updated.
sub init {
    my $self = shift;
    my $tempfiledir = $self->{'temptopdir'};
    my @dirlist = (split("/", $tempfiledir));
    my $path = "";
    my @fullpath = ();
    my ($pidfh, $inode, $pid, $in, $pidfound, $filename, $mfh);

    my ($nowepoch, $line, $key, $keyid, $prevkeyid, $numsigs,
	$keyexpiryepoch, $keyrevokepoch, $kstatus);

    my @allkeys = ();
    my %activekeys = ();
    my %preskippedkeys = ();
    my %expiredkeys = ();
    my %revokedkeys = ();
    my %signaturesexceededkeys = ();
    my %processedsignlimits = ();

    my ($confdpreskips, $signlimits, $curr_sigs, $max_sigs, $max_new_sigs, $num,
	$global_max, $global_max_new);

    if (! -d $self->{'masterringdir'}) {
	$logger->fatal("Master ring $self->{'masterringdir'} doesn't exist");
	return ("", 11);
    }

    for my $oldring ( ['pubring.gpg', 'a GPGv2 keyring pubring.kbx'],
		   ['secring.gpg', 'the GPGv2 private key dir private-keys-v1.d' ] ) {
	if (-e "$self->{'masterringdir'}/$oldring->[0]") {
	    $logger->warn("$self->{'masterringdir'} contains a GPGv1 keyring $oldring->[0].");
	    $logger->warn("Migrate its contents to $oldring->[1].");
	    $logger->warn("GPGv2 keyrings *only* are refreshed with this script.");
	}
    }

    if (!sysopen($pidfh, "$self->{'masterringdir'}/gpg-key-ring-refresher.pid",
		O_WRONLY|O_CREAT|O_EXCL|O_NONBLOCK)) {
	$inode = (stat("$self->{'masterringdir'}/gpg-key-ring-refresher.pid"))[1];
        if (open(PROCLFH, "/proc/locks")) {
	    # we do our best to find out who's the culprit
	    $pidfound = -1;
	    while (my $lockinfo = <PROCLFH>) {
		($pid, $in) = (split(/[:\s]+/,$lockinfo))[4,7];
		if ($in == $inode) {
		    $logger->fatal("Process $pid has already locked master ring pid file");
		    $pidfound = $pid;
		    last;
		}
	    }
	    close(PROCLFH);
        }
        if ($pidfound == -1) {
	    # someone just left a pid file laying around and not cleaning it up,
	    # but he is not running anymore.
	    # we can try to unlink it and then recreate it.
	    unlink "$self->{'masterringdir'}/gpg-key-ring-refresher.pid";
        }
        # we retry
	if (!sysopen($pidfh, "$self->{'masterringdir'}/gpg-key-ring-refresher.pid",
		     O_WRONLY|O_CREAT|O_EXCL|O_NONBLOCK)) {
	    $logger->fatal("Unable to create new master ring pid file.");
	    return ("", 12);
        }
    }

    # Success!

    if (!flock($pidfh, LOCK_EX|LOCK_NB)) {
	$logger->fatal("Failed to write lock master ring gpg-key-ring-refresher.pid");
	return ("", 13);
    }

    # locked opening of pid file succeeded.
    print $pidfh "$$\n";
    $self->{'pidfilehandle'} = $pidfh;
    
    for $filename (keys %{$self->{'files_to_manage'}}) {
	my $md5 = Digest::MD5->new;
	if (!sysopen($mfh, "$self->{'masterringdir'}/$filename",
		     O_RDONLY|O_NONBLOCK)) {
	    $logger->fatal("Failed to open master ring $filename");
	    return ("", 14);
	}
	$md5->addfile($mfh);
	close($mfh);
	my @statinfo = stat "$self->{'masterringdir'}/$filename";
	${$self->{'files_to_manage'}}{$filename} =
            { 'userid' => "$statinfo[4]",
	      'groupid' => "$statinfo[5]",
	      'size' => "$statinfo[7]",
	      'md5' => $md5->b64digest(),
	      'accessmode' => sprintf("%04o",$statinfo[2] & 07777) };
    }
    
    shift @dirlist;
    while (defined(my $dir = shift @dirlist)) {
        $path .= "/$dir";
	if (! -d "$path") {
	    push @fullpath, $path;
	    last;
	}
	else {
	    $logger->debug("Dir $path exists");
	}
    }

    $logger->warn("Temp dir $self->{'temptopdir'} exists already, we overwrite its contents")
        if (!@fullpath);
    
    # Create necessary temp dirs for temp files
    for my $dir (@dirlist) {
	push @fullpath, $path;
	$path .= "/$dir";
    }
    
    push @fullpath, ($self->{'mastercopydir'}, $self->{'workringdir'});

    # Creating the missing dirs in the temp dir tree one by one working
    # downwards the dir tree one level at a time.
    while (my $dir = shift @fullpath) {
	next if (-d "$dir"); # 
	if (! mkdir "$dir") {
	    $self->close();
	    $logger->fatal("Failed to create temp dir $dir");
	    return ("", 15);
	}
    }

    $logger->debug("Set up temp ring dir $self->{'temptopdir'}");

    # Setting up the mastercopy and workring gnupg dirs.
    $self->_copyring($self->{'masterringdir'}, $self->{'mastercopydir'});
    $self->_copyring($self->{'mastercopydir'}, $self->{'workringdir'});

    # Here we read in all the keys and count their signatures.
    # timestamp now as seconds after epoch
    $nowepoch = time();
    $key = $keyid = $keyexpiryepoch = $keyrevokepoch = 0;

    if (open(PUBKEYSFH, "$self->{'gpgexecutable'} --homedir $self->{'mastercopydir'} --batch --no-tty --keyid-format=long --with-colons --list-sigs 2>&1 |")) {
	# Read lines until we hit the pub key entry (or EOF)
	while ($line = <PUBKEYSFH>) {
	    chomp $line;
	    if ($line =~ /^pub:[^:]*:[^:]*:[^:]*:([A-F\d]{16}):[^:]*:(\d*):/o) {
		# found first key
		$keyid = $1;
		$keyexpiryepoch = $2 || 0;
		$keyrevokepoch = 0;
		last;
	    }
	}

	if (defined $keyid) {
	    $prevkeyid = $keyid; # handling the case of a one key only key ring
	    # We now have at least one public key
	    $numsigs = 0;
	    while ($line = <PUBKEYSFH>) {
	        if ($line =~ /^sig:/o) {
		    $numsigs++;
		    next;
		}
		if ($line =~ /^pub:[^:]*:[^:]*:[^:]*:([A-F\d]{16}):[^:]*:(\d*):/o) {
		    # found next key, let's store the previous one
		    $key = Key->new($keyid, $numsigs);
		    $key->setStatus(Key::EXPIRED) if ($keyexpiryepoch and ($keyexpiryepoch < $nowepoch));
		    $key->setStatus(Key::REVOKED) if ($keyrevokepoch);
		    push @allkeys, $key;
		    # next key
		    $keyid = $1;
		    $keyexpiryepoch = $2 || 0;
		    $keyrevokepoch = 0;
		    $numsigs = 0;
		    next;
		}
		if ($line =~ /^rev:[^:]*:[^:]*:[^:]*:[^:]*:(\d+):/o) {
		    $keyrevokepoch = $1;
		}
	    }
	}
	close(PUBKEYSFH);

	# Save last key data here if you have one!
	if (defined $keyid and ($keyid ne $prevkeyid)) {
	    $key = Key->new($keyid, $numsigs);
	    $key->setStatus(Key::EXPIRED) if ($keyexpiryepoch and ($keyexpiryepoch < $nowepoch));
	    $key->setStatus(Key::REVOKED) if ($keyrevokepoch);
	    push @allkeys, $key;
	}
	
	# We order the keys to different subsets
	$confdpreskips = $self->{'confdpreskiplist'};
	$signlimits = $self->{'signaturelimits'};
	$global_max = $self->{'global_max_sigs'};
	$global_max_new = $self->{'global_max_new_sigs'};
	foreach $key (@allkeys) {
	    $kstatus = $key->getStatus();
	    $keyid = $key->getId();
	    if (exists $confdpreskips->{$keyid}) {
		# remove the key from the configured preskiplist
		delete ${$confdpreskips}{$keyid};
		# put the key to the preskiplist
		$key->setStatus(Key::ON_PRESKIPLIST);
		$preskippedkeys{$keyid} = $key;
		next;
	    }
	    if ($kstatus == Key::NOT_SEARCHED_FOR) {
		# count the keywise signature limits here
		$curr_sigs = $key->getNumSignatures();
		($max_sigs, $max_new_sigs) =
		    (exists ${$signlimits}{$keyid} ?
		     $signlimits->{$keyid}->getLimits() :
		     ($global_max, $global_max_new));
		$num = ($max_sigs > $curr_sigs ? $max_sigs - $curr_sigs : 0);
		$num = (($max_new_sigs < $num and $max_new_sigs > 0) ? $max_new_sigs : $num);
		$num = $max_new_sigs if ($max_sigs == 0);
		$num = -1 if ($max_sigs <= 0 and $max_new_sigs <= 0);
		$key->setMaxNewSignatures($num);
		if ($num == 0) {
		    $key->setStatus(Key::SIGN_LIMIT_EXCEEDED);
		    $signaturesexceededkeys{$keyid} = $key;
		}
		else {
		    $activekeys{$keyid} = $key;
		}
		# We move the KeySignatureLimits info to the processed ones
		# after it has been handled.
		if (exists ${$signlimits}{$keyid}) {
		    $processedsignlimits{$keyid} = ${$signlimits}{$keyid};
		    delete ${$signlimits}{$keyid};
		}
		next;
	    }
	    if ($kstatus == Key::EXPIRED) {
		$expiredkeys{$keyid} = $key;
		next;
	    }
	    if ($kstatus == Key::REVOKED) {
		$revokedkeys{$keyid} = $key;
		next;
	    }

	    $logger->fatal("We should never land here!");
	}
    }

    # Store the different key sets here for later reference
    $num = 0;
    for my $e ( [ 'active_keys', \%activekeys ],
		[ 'preskipped_keys', \%preskippedkeys ],
		[ 'signatures_exceeded_keys', \%signaturesexceededkeys ],
		[ 'processed_sign_limits', \%processedsignlimits ],
		[ 'expired_keys', \%expiredkeys ],
		[ 'revoked_keys', \%revokedkeys ] ) {
	my @o =(@{$e});
	${$self}{$o[0]} = $o[1]; # store the keys for later reference
	my $temp = scalar(keys %{$o[1]});
	$num += $temp; # counting totals
    }
    $num += (keys %{$self->{'confdpreskiplist'}}) +
      (keys %{$self->{'signaturelimits'}}) -
      (keys %processedsignlimits); # let's subtract the anomaly introduced
                                   # above.
    ${$self}{'total_num_key_ids'} = $num;
    ("", 0);
}
    
sub getKeys {
    my ($self, $keytype) = @_;

    $self->{$keytype};
}

sub numAllKeys {
    $_[0]->{'total_num_key_ids'};
}
      
sub getMasterRingDir {
    $_[0]->{'masterringdir'};
}

sub deleteGPGRefreshRunFilesFromWorkRingDir {
    my $self = shift;
    my $absdirname = $self->{'workringdir'};

    for my $fname ('gpg-refresh-run.output', 'S.dirmngr', 'S.gpg-agent',
		'S.gpg-agent.ssh', 'S.gpg-agent.browser', 'S.gpg-agent.extra') {
        unlink "$absdirname/$fname"
            if (-e "$absdirname/$fname");
    }
}

# Copy from one GPG dir to another, absolute and relative paths are allowed.
# Assumes source and target dirs exist.
sub _copyring {
    my ($self, $fromdir, $todir) = @_;

    # Turn relative paths to absolute 
    $fromdir = "$self->{'temptopdir'}/$fromdir" if ($fromdir !~ m#^/#o);
    $todir = "$self->{'temptopdir'}/$todir" if ($todir !~ m#^/#o);

    if (! -d "$fromdir") {
	$logger->fatal("GPG source dir $fromdir doesn't exist");
	return ("", 17);
    }
    if (! -d "$todir") {
	$logger->fatal("GPG target dir $todir doesn't exist");
        return ("", 18);
    }

    for my $file (keys %{$self->{'files_to_manage'}}) {
	`$self->{'copyexecutable'} $fromdir/$file $todir/$file`;
        if ($? != 0) {
	    $logger->fatal("Failed to copy $file to $todir.");
	    return ("", 19);
	}
    }
    $self->deleteGPGRefreshRunFilesFromWorkRingDir();
}

# Copy the master copy ring (in consistent state) over to work ring
# (the work ring is potentially in an inconsistent state).
sub reinstateWorkRingFromMasterCopy {
    my $self = shift;
    $self->_copyring($self->{'mastercopydir'}, $self->{'workringdir'});
}

# Copy the successfully updated work ring (in consistent state) over to
# the master copy ring (the master copy is in previous consistent state).
sub updateMasterCopyFromWorkRing {
    my $self = shift;

    $self->_copyring($self->{'workringdir'}, $self->{'mastercopydir'});
    $self->{'successfulupdates'} = 1;
}

sub close {
    my $self = shift;
    my ($filename, $fmeta, $mfh);
    my $master_changed_while_refreshing = 0;
    
    if ($self->{'successfulupdates'}) {
        while (($filename, $fmeta) = 
	       each %{$self->{'files_to_manage'}}) {
	    my $md5 = Digest::MD5->new();
	    if (!open($mfh, "$self->{'masterringdir'}/$filename")) {
		$logger->fatal("Failed to open master $filename");
		$master_changed_while_refreshing = 1;
		next;
	    }
	    my $size = (stat "$self->{'masterringdir'}/$filename")[7];
	    $md5->addfile($mfh);
	    close($mfh);
	    if (($md5->b64digest() ne $fmeta->{'md5'}) or 
		($size != $fmeta->{'size'})) {
		$logger->fatal("Master $filename has changed while refreshing");
		$master_changed_while_refreshing = 1;
	    }
       }

       if (!$master_changed_while_refreshing) {
	  # copy mastercopy over to true master ring!
	  $self->_copyring($self->{'mastercopydir'}, $self->{'masterringdir'});

	  # Restore collected file meta data against the master key
	  # ring files.
	  while (($filename, $fmeta) = 
		 each %{$self->{'files_to_manage'}}) {
	      my %orig = %{$fmeta};
	      my $absfilename = "$self->{'masterringdir'}/$filename";
	      my @statinfo = stat "$absfilename";
	      my %seen = ( 'userid' => "$statinfo[4]",
			   'groupid' => "$statinfo[5]",
			   'accessmode' => sprintf("%04o",$statinfo[2] & 07777) );
	      for my $attr ('accessmode', 'userid', 'groupid') {
		  my $changecount = 0;
		  next if ("$orig{$attr}" eq "$seen{$attr}");
		  if ($attr eq "accessmode") {
		      $changecount = chmod oct($orig{'accessmode'}), "$absfilename";
		  }
		  elsif ($attr eq "userid") {
		      # uid and gid
		      $changecount = chown $orig{'userid'}, -1, "$absfilename";
		  }
		  elsif ($attr eq "groupid") {
		      # uid and gid
		      $changecount = chown -1, $orig{'groupid'}, "$absfilename";
		  }

		  if ($changecount != 1) {
		      $logger->fatal("Failed to restore $attr to $orig{$attr} on $absfilename");
		      return ("", 20);
		  }
	      }
	  }
	  $logger->warn("Master key ring under $self->{'masterringdir'} was updated.");
      }
      else {
	  $self->{'skip_tempdir_deletion'} = 1;
	  $logger->fatal("Leaving updated copy of the master key ring into ",
			 $self->{'mastercopyringdir'});
      }
   }

   if (!$self->{'successfulupdates'} or $master_changed_while_refreshing) {
       $logger->info("Master key ring under $self->{'masterringdir'} not updated - no new key info found.");
   }

   if (!$self->{'skip_tempdir_deletion'}) {
       $logger->debug("Deleting temp ring dir $self->{'temptopdir'}");
       $self->_deletetempringdirs($self->{'temptopdir'});
   }

    # Removing pid file.
    unlink "$self->{'masterringdir'}/gpg-key-ring-refresher.pid"
	if (-e "$self->{'masterringdir'}/gpg-key-ring-refresher.pid");

    ("", 0);
}

sub _deletetempringdirs {
    my ($self, $dirname) = @_;
    my $dh;
    my @names = ();

    if (!opendir($dh, "$dirname")) {
	$logger->fatal("Failed to open directory $dirname for removal");
	return;
    }

    @names = map { "$dirname/$_" } (grep { $_ !~ /^\.\.?$/go } readdir($dh));
    closedir($dh);

    foreach my $e (@names) {
	if (-d $e) {
	    $self->_deletetempringdirs($e);
	}
	else {
	    unlink $e;
	}
    }
    rmdir "$dirname";
}


package main;

our $logger = get_logger(__PACKAGE__);

sub usage() {
    my $thiscommand = shift;
    
"
A programme for refreshing a GPG2 key ring against info from PGP key servers.

    $thiscommand { -c conf_file_name | -H } [ -g gnupghomedir |
		  -w seconds | -s seconds | -r max_seconds |
		  -k number | -f number ] refresh
    $thiscommand -h
    $thiscommand { [ -c conf_file_name ] showconf | siginfo | help }

    Options:
      -c = use given configuration file
      -H = use hard-coded configuration only
      -g = GnuPG home under which pubring.kbx and trustdb.gpg files are
           expected to be found. This is the key ring to be refreshed
           (conf option KEYRINGGNUPGHOME)
      -w = wait upto given number of seconds before assuming the refresh
           request to a PGP key server has failed (default is 180 seconds
           and this is the allowed maximum wait time, conf option
           MAX_WAIT_REFRESH_REQUEST_SECONDS)
      -s = sleep given amount of seconds between refresh tries (default 180,
           conf option WAIT_GIVEN_SECONDS_BETWEEN_REFRESH_REQUESTS)
      -r = sleep max random seconds between refresh tries (default 120,
           conf option WAIT_MAX_RANDOM_SECONDS_BETWEEN_REFRESH_REQUESTS)

           NB: wait times given with options -s and -r are summed up.
           These are intended to prevent swamping the pgp key servers
           with requests.

      -k = number of keys to refresh per refresh request (default 20,
           conf option NUM_KEYS_TO_REFRESH_PER_REQUEST)
      -f = max number of consecutively failed refreshes per key server
           (default 10, conf option
            MAX_NUMBER_OF_CONSECUTIVELY_FAILED_REFRESH_ATTEMPTS_PER_KEY_SERVER)
      -h = this help

    Commands:
      showconf  - show configuration parameters and values used	
      refresh   - refresh the key ring (requires either option -c or -H)
      siginfo   - show key ring signatures
      help      - this help (same as option h)

    v0.1.5
";
}

# We will eventually bump into an error (whilst this programme is run by
# cron) that will spit out the single error message line below wrapped
# into a cron alert message. Problem is, we can't completely avoid these
# since errors may happen before necessary config info is available.
sub outputmsg_and_exit {
    my ($msg, $status) = @_;

    if ($msg) {
	$status ? print STDERR "$msg\n" : print "$msg\n";
    }
    exit($status);
}

sub dayshoursminssecs {
    my $secs = shift;
    my ($div, $rem);
    my @units = ();
    my ($ans);
    
    use integer;
    for $div (60, 60, 24) {
	$rem = $secs % $div;
	$secs = $secs / $div;
	unshift @units, $rem;
    }

    $ans = ($secs) ? "$secs days, " : "";
    $ans .= sprintf("%0.2d:%0.2d:%0.2d", @units);
    $ans;
}

sub read_config_file {
    my ($conffilename, $allowedparams) = @_;
    my ($line, $key, $value, $check);
    my $confsection = undef;
    my %configuration = ();
    my @tempkeyservers = ();
    my @tempskipkeys = ();
    my @signaturelimits = ();
    my $fileloggerconf = "";

    if (open(CFILE, "$conffilename")) {
	do {
	    # Read lines until we hit the first conf section or EOF
	    $line = <CFILE>;
	    chomp $line;
	    if ($line =~ /^\]\[\]\s*(\w[\w\_\-\d]*)\s*\]\]\[\s*$/o) {
		# change of conf section
		$confsection = $1;
	    }
	} while (!defined $confsection and (defined $line));

	if (!defined $confsection) {
	    close(CFILE);
	    return ("No configuration section defined in $conffilename", 23);
	}

	# We now have a $confsection defined
	do {
	    if ($confsection !~ /^(?:i_am_no_great_fan_of_ini_files|hmmm___some_key_servers_are_also_needed|skip_these_gpg_keys|and_logging_to_a_file_would_be_handy|key_specific_signature_limits)$/o) {
		close(CFILE);
		return ("Unknown configuration section name $confsection", 24);
	    }

	    # Read lines until we hit a new conf section or EOF
	    while ($line = <CFILE>) {
		chomp $line;
		if ($line =~ /^\]\[\]\s*(\w[\w\_\-\d]*)\s*\]\]\[\s*$/o) {
		    # change of conf section
		    $confsection = $1;
		    last;
		}

		if ($confsection eq "i_am_no_great_fan_of_ini_files") {
		    next if ($line =~ /^\s*(?:#.*)?$/go);
		    if ($line =~ /^(\w[\w\d\-\_]*)=(.*)$/go) {
			$configuration{$1} = $2;
		    }
		    else {
			return ("Malformed configuration line $line in section $confsection", 25);
		    }
		}
		elsif ($confsection eq "hmmm___some_key_servers_are_also_needed") {
		    next if ($line =~ /^\s*(?:#.*)?$/go);
		    if ($line =~ /^\s*(\w[\w\d\.\-]*)\s*$/go) {
			push @tempkeyservers, $1;
		    }
		    else {
			return ("Malformed pgp key server entry \"$line\" in section $confsection", 26);
		    }
		}
		elsif ($confsection eq "skip_these_gpg_keys") {
		    next if ($line =~ /^\s*(?:#.*)?$/go);
		    if ($line =~ /^\s*(?:0x)?([a-f\d]{16})\s*$/io) {
			push @tempskipkeys, uc($1);
		    }
		    else {
			return ("Malformed key skip entry \"$line\" in section $confsection", 27);
		    }
		}	    
		elsif ($confsection eq "key_specific_signature_limits") {
		    next if ($line =~ /^\s*(?:#.*)?$/go);
		    if ($line =~ /^\s*(?:0x)?([a-f\d]{16})\s+(\d+)\s+(\d+)\s*$/io) {
			push @signaturelimits, uc($1) . " $2 $3";
		    }
		    else {
			return ("Malformed signature limit entry \"$line\" in section $confsection", 27);
		    }
		}
		elsif ($confsection eq "and_logging_to_a_file_would_be_handy") {
		    $fileloggerconf .= "$line\n";
		}
		else {
		    return ("We never get here! (hopefully)", 28);
		}
	    }
	} while (defined $line);
	close(CFILE);
    }
    else {
	return("Unable to open conf file $conffilename.", 29);
    }

    # We override the hard-coded confs iff the config file defines them.
    $configuration{'PRESKIPLIST'} = \@tempskipkeys if (@tempskipkeys);
    $configuration{'KEYSERVERS'} = \@tempkeyservers if (@tempkeyservers);
    $configuration{'FILELOGGERCONF'} = $fileloggerconf if ($fileloggerconf ne "");
    $configuration{'KEY_SPECIFIC_SIGNATURE_LIMITS'} = \@signaturelimits if (@signaturelimits);
    (\%configuration, 0);
}

sub check_configs {
    my ($conf, $allowedparams) = @_;
    my ($key, $value, $check);

    # Check the conf values merged from conf file and hard-coded ones.
    for $key (sort keys %{$conf}) {
	return ("Unknown configuration parameter name $key.", 30) if (!exists ${$allowedparams}{$key});
	# Run the given value through the checker to make sure it is as expected
	$value = $conf->{$key};
	$check = $allowedparams->{$key}->[1]($value);
	return ("Conf parameter ${key}\'s value didn't pass the check, $check", 31) if ($check);
    }

    ("", 0);
}

sub _confprint {
    my ($key, $value, $indent) = @_;

    if (ref($value) eq "ARRAY") {
	print " " x $indent, "$key:\n";
	$indent++;
        foreach (@{$value}) { &_confprint(undef, $_, $indent); }
    }
    elsif (ref($value) eq "HASH") {
	print " " x $indent, "$key:\n";
	$indent++;
	while(my ($k,$v) = each %{$value}) {
	    &_confprint($k, $v, $indent);
	}
    }
    else {
	print " " x $indent, ($key ? "$key=$value\n" : "$value\n");
    }
}
    
sub show_configuration {
    my ($c, $a, $m) = @_;
    my $msg = "";
    my ($key, $value);
    my $cs = "hard-coded defaults";
    my @confsources = ();
    
    unshift @confsources, $m->{'c'} if (defined $m->{'c'});
    unshift @confsources, "command line" if (defined $m->{'cli_options_given'});
    if (@confsources) {
	$cs = (@confsources == 2) ?
	    "$confsources[0], $confsources[1] and $cs" :
	    "$confsources[0] and $cs";
    }

    print "From $cs:\n";
    for $key (sort keys %{$c}) {
	$value = $c->{$key};
	&_confprint($key, $value, 0);
    }
    ("", 0);
}

sub show_sign_info {
    my ($c, $a, $m) = @_;
    my ($msg, $status);
    my ($kib, $ksb, $krm, $keyid);
    my $tempringtopdir = "$c->{'TEMPKEYRINGTOPDIRSTEM'}.$$";
    my $mns;
    
    my $logger = Log::Log4perl->get_logger("sign_info");
    
    $krm = KeyRingManager->new($c->{'KEYRINGGNUPGHOME'},
			       "$c->{'TEMPKEYRINGTOPDIRSTEM'}.$$",
			       $c->{'PRESKIPLIST'},
			       $c->{'KEY_SPECIFIC_SIGNATURE_LIMITS'},
			       $c->{'MAX_NUMBER_OF_SIGNATURES_PER_KEY'},
			       $c->{'MAX_NUMBER_OF_NEW_SIGNATURES_PER_KEY'},
			       $a->{'GPGCMD'},
			       $a->{'CPCMD'});
    ($msg, $status) = $krm->init();
    for my $e ( ['Active keys', 'active_keys' ],
		['Known keys on preskip list', 'preskipped_keys' ],
		['Unknown keys on preskip list', 'confdpreskiplist' ],
		['Known keys with too many signatures', 'signatures_exceeded_keys' ],
		['Known keys on key signature limit list', 'processed_sign_limits' ],
		['Unknown keys on key signature limit list', 'signaturelimits' ],
		['Expired keys', 'expired_keys' ],
		['Revoked keys', 'revoked_keys' ]
	) {
	my @o =(@{$e});
	my $keys = $krm->getKeys($o[1]);
	my $numkeys = scalar(keys %{$keys});
	print "$o[0] ($numkeys)", ($numkeys ? ":\n" : "\n");
	foreach my $k (sort keys %{$keys}) {
	    print " $k";
	    if (ref($keys->{$k}) eq "Key") {
		print ": sigs(", $keys->{$k}->getNumSignatures(), ")";
		if ($keys->{$k}->getStatus() <= 1) {
		    $mns = $keys->{$k}->getMaxNewSignatures();
		    print (($mns >= 0) ?
			   ", max new signatures on next refresh $mns" :
			   ", number of new signatures is unlimited!");
		}
	    }
	    print "\n";
	}
    }
    print "Total number of unique key identifiers is ", $krm->numAllKeys(), ".\n";
    $krm->close();
}
    
sub update_key_ring {
    my ($c, $a, $m) = @_;
    my ($msg, $status);
    my ($kib, $ksb, $krm, $keyid);
    my $keychunk = [];
    my $verifykeys;
    my $server = "";
    my @orderedservers = ();
    my $tempringtopdir = "$c->{'TEMPKEYRINGTOPDIRSTEM'}.$$";
    
    my $logger = Log::Log4perl->get_logger("update");
    
    $logger->info("Starting $m->{'thecommand'} execution on $c->{'KEYRINGGNUPGHOME'}, ",
		  scalar(localtime($m->{'starttimestamp'})));
    
    $krm = KeyRingManager->new($c->{'KEYRINGGNUPGHOME'},
			       $tempringtopdir,
			       $c->{'PRESKIPLIST'},
			       $c->{'KEY_SPECIFIC_SIGNATURE_LIMITS'},
			       $c->{'MAX_NUMBER_OF_SIGNATURES_PER_KEY'},
			       $c->{'MAX_NUMBER_OF_NEW_SIGNATURES_PER_KEY'},
			       $a->{'GPGCMD'},
			       $a->{'CPCMD'});
    ($msg, $status) = $krm->init();
    goto CLEANUP_AND_QUIT if ($status);

    $logger->info("Total number of unique key ids including skip and signature limit lists: ", $krm->numAllKeys());
    for my $e (	['Known keys on preskip list', 'preskipped_keys', 0 ],
		['Unknown keys on preskip list', 'confdpreskiplist', 1 ],
		['Known keys with too many signatures', 'signatures_exceeded_keys', 1 ],
		['Known keys on key signature limit list', 'processed_sign_limits', 0 ],
		['Unknown keys on key signature limit list', 'signaturelimits', 1],
		['Expired keys', 'expired_keys', 0 ],
		['Revoked keys', 'revoked_keys', 0 ],
		['Keys to refresh', 'active_keys', 0 ]
	) {
	my @o =(@{$e});
	my $keys = $krm->getKeys($o[1]);
	my $numkeys = scalar(keys %{$keys});
	$logger->info("$o[0] ($numkeys)",
		      (($numkeys and ($logger->is_debug() or $o[2])) ? ":" : ""));
	if ($logger->is_debug() or $o[2]) {
	    foreach my $k (sort keys %{$keys}) {
		if (ref($keys->{$k}) eq "Key") {
		    $logger->info(" $k: sigs(", $keys->{$k}->getNumSignatures(),
				  ")", (($keys->{$k}->getStatus() <= 1) ?
					", max new sigs " .
					$keys->{$k}->getMaxNewSignatures() : ""));
		}
		else {
		    $logger->info(" $k");
		}
	    }
	}
    }
    
    $logger->warn("No keys to refresh, check that the configured GPG pubring.kbx is not empty")
	if (scalar(keys %{$krm->getKeys('active_keys')}) == 0);

    $kib = KeyIdBookie->new($krm->getKeys('active_keys'),
			    scalar(@{$c->{'KEYSERVERS'}}),
			    $c->{'NUM_KEYS_TO_REFRESH_PER_REQUEST'});
    $ksb = KeyServerBookie->new($c->{'KEYSERVERS'},
				$c->{'MAX_NUMBER_OF_CONSECUTIVELY_FAILED_REFRESH_ATTEMPTS_PER_KEY_SERVER'},
				$c->{'MAX_WAIT_REFRESH_REQUEST_SECONDS'});

    $logger->info("Starting refresh runs ...");
    while (1) {
	($keychunk, $server) =
	    $kib->keyChunkToRefreshFromServer($ksb->orderKeyServersBestFirst());
	# No server could offer info on keys, or no keys can be refreshed with
	# the available servers.
	last if (!@{$keychunk} or (!defined $server));
	
	$logger->debug("Selected ", $server->getName(), " for refresh attempt");
	$logger->debug("Refreshing ", scalar(@{$keychunk}), " key ids.");
	
	($msg, $status) = $server->attemptKeyUpdate($a->{'GPGCMD'},
						    "$tempringtopdir/workring",
						    "$tempringtopdir/workring/gpg-refresh-run.output",
						    @{$keychunk});

	goto CLEANUP_AND_QUIT if ($status);
	
	# The gpg sub command output has been read by now.
	$krm->deleteGPGRefreshRunFilesFromWorkRingDir();
	
	# Record whatever key info was found.
	$kib->recordKeyInfo($server, @{$msg});
	
	if ($server->isWorkRingDirIntactAfterLastRefresh()) {
	    # yes.
	    if ($server->wasWorkRingDirUpdatedInLastRefresh()) {
		($msg, $status) = $krm->updateMasterCopyFromWorkRing();
		goto CLEANUP_AND_QUIT if ($status);
	    }
	}
	else {
	    # no. reinstate a new intact work ring from master copy
	    ($msg, $status) = $krm->reinstateWorkRingFromMasterCopy();
	    goto CLEANUP_AND_QUIT if ($status);
	}

	# Do we need to politeness sleep before the next refresh round or
	# can we just finish?
	($keychunk, $server) =
	    $kib->keyChunkToRefreshFromServer($ksb->orderKeyServersBestFirst());
	last if (!@{$keychunk} or (!defined $server));

	# There are keys left to be searched for but we try to be nice
	# with the key servers
	my $st = int(rand($c->{'WAIT_MAX_RANDOM_SECONDS_BETWEEN_REFRESH_REQUESTS'})) +
	    $c->{'WAIT_GIVEN_SECONDS_BETWEEN_REFRESH_REQUESTS'};

	if ($st) {
	    $logger->debug("Being nice with key servers - sleeping $st seconds");
	    sleep $st;
	}
    }
    
    # keys unchanged, updated, not found, num tries, success rate etc
    $logger->info("Result of refresh runs:");
    $kib->stats();
    # key server reliability, num requests, success rate etc
    $ksb->stats();
    $msg = undef;
    
  CLEANUP_AND_QUIT:
    $logger->info($msg) if ($msg);

    # Closing takes care of updates to the true master ring if necessary.
    my ($msg2, $status2) = $krm->close();
    $logger->warn($msg2) if ($status2);

    $status = $kib->getStatus() if (!$status);
    $logger->info("Finished $m->{'thecommand'} run, ", scalar(localtime()),
		  " (status $status, duration ",
		  &dayshoursminssecs(time() - $m->{'starttimestamp'}), ")");

    # Mangling the return values
    ($msg, $status) = ($status ? ($msg, $status) : ($msg2, $status2));
    `$a->{'TTYCMD'} -s > /dev/null 2>&1`;
    $status = 0 if ($? != 0);
    ($msg, $status);
}

sub ensure_we_have_aux_executables {
    my ($pickfrom, $aux) = @_;
    my @missing = ();
    my ($cmdname, $candidates);

    while (($cmdname, $candidates) = each %{$pickfrom}) {
        my $found = 0;
        for my $exe (@{$candidates}) {
            `which $exe > /dev/null`;
            if (-x "$exe" or $? == 0) {
               $found = "$exe";
               $aux->{$cmdname} = $found;
               last;
            }
        }
        if (!$found) {
            push @missing, join(", ", @{$candidates});
        }
    }
    @missing;
}

sub main () {
    my %opts = ();
    my $conffile;
    my ($msg, $status);
    my %preaux = (
	'GPGCMD' => [ '/usr/bin/gpg' ],
	'CPCMD' => [ '/usr/bin/cp', '/bin/cp' ],
	'TTYCMD' => [ '/usr/bin/tty' ]
	);

    my %aux = ();

    my %opttoconfmap = (
	'g' => 'KEYRINGGNUPGHOME',
	'w' => 'MAX_WAIT_REFRESH_REQUEST_SECONDS',
	's' => 'WAIT_GIVEN_SECONDS_BETWEEN_REFRESH_REQUESTS',
	'r' => 'WAIT_MAX_RANDOM_SECONDS_BETWEEN_REFRESH_REQUESTS',
	'k' => 'NUM_KEYS_TO_REFRESH_PER_REQUEST',
	'f' => 'MAX_NUMBER_OF_CONSECUTIVELY_FAILED_REFRESH_ATTEMPTS_PER_KEY_SERVER',
	);

    my %B = (
	'KEYRINGGNUPGHOME' => [
	    "$ENV{'HOME'}/.gnupg",
	    sub {
		return "$_[0] is not an absolute path name." if ($_[0] !~ m#^/#);
		return "$_[0] cannot end in a / character." if ($_[0] =~ m#/$#);
		return "$_[0] not a directory or it doesn't exist." if ((! -d "$_[0]") or (! -e "$_[0]"));
		return "$_[0] is missing pubring.kbx and/or trustdb.gpg files." if ((! -r "$_[0]/pubring.kbx") or (! -r "$_[0]/trustdb.gpg"));
		0;
	    } ],
	'TEMPKEYRINGTOPDIRSTEM' => [
	    '/tmp/gpg-key-ring-refresher',
	    sub {
		return "$_[0] is not an absolute path name." if ($_[0] !~ m#^/#);
		return "$_[0] cannot end in a / character." if ($_[0] =~ m#/$#);
		0;
	    } ],
	# The fallback pgp key servers. These are used unless the config file
	# states its own pgp key servers.
	'KEYSERVERS' => [
	    [
 	     'pgp.surfnet.nl',
	     'pgp.circl.lu',
	     'keys.openpgp.org',
#	      'keys.gnupg.net',
#	      'pgp.mit.edu',
	     'keyserver.ubuntu.com' ],
	    sub {
		my ($kn);
		my @list;
		return "Expecting list of key server names, got " . ref($_[0]) if (ref($_[0]) ne "ARRAY");
		@list = @{$_[0]};
		for $kn (@list) {
		    return "Couldn't resolve key server $kn." if (!gethostbyname($kn));
		}
		0;
	    } ],
	'PRESKIPLIST' => [
	    [ ],
	    sub {
		my $kid;
		my %seen = ();
		return "Expecting a list of hex key ids to skip, got " . ref($_[0]) if (ref($_[0]) ne "ARRAY");
		for $kid (@{$_[0]}) {
		    return "Not a valid hex form key id (16 digit) $kid." if ($kid !~ /^(?:0x)?[a-f\d]{16}$/io);
		    return "A repeated key id on the preskip list: $kid"
			if (exists $seen{$kid});
		    $seen{$kid} = 1;
		}
		0;
	    } ],
	'FILELOGGERCONF' => [
"log4perl.rootLogger=INFO, LOGFILE
log4perl.appender.LOGFILE=Log::Log4perl::Appender::File
log4perl.appender.LOGFILE.filename=sub { \"$ENV{HOME}/.gpg-key-ring-refresher.log\"; }
log4perl.appender.LOGFILE.mode=append
log4perl.appender.LOGFILE.layout=PatternLayout
log4perl.appender.LOGFILE.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} [%p] - %m%n",
	    sub {
		my $prevhandler = $SIG{__WARN__};
		local $SIG{__WARN__} = sub { };
		Log::Log4perl->init(\$_[0]);
		$SIG{__WARN__} = $prevhandler;
		return "Not a log4perl conf: $_[0]."
		    if (defined $Log::Log4perl::Config::CONFIG_INTEGRITY_ERROR);
		0;
	    } ],
	'MAX_WAIT_REFRESH_REQUEST_SECONDS' => [
	    180,
	    sub { return "Expecting an integer value instead of $_[0]." if ($_[0] !~ /^\d+$/o);
		  0;
	    } ],
	'WAIT_GIVEN_SECONDS_BETWEEN_REFRESH_REQUESTS' => [
	    180,
	    sub { return "Expecting an integer value instead of $_[0]." if ($_[0] !~ /^\d+$/o);
		  0;
	    } ],
	'WAIT_MAX_RANDOM_SECONDS_BETWEEN_REFRESH_REQUESTS' => [
	    120,
	    sub { return "Expecting an integer value instead of $_[0]." if ($_[0] !~ /^\d+$/o);
		  0;
	    } ],
	'NUM_KEYS_TO_REFRESH_PER_REQUEST' => [
	    20,
	    sub { return "Expecting an integer value instead of $_[0]." if ($_[0] !~ /^\d+$/o);
		  0;
	    } ],
	'MAX_NUMBER_OF_CONSECUTIVELY_FAILED_REFRESH_ATTEMPTS_PER_KEY_SERVER' => [
	    10,
	    sub { return "Expecting an integer value instead of $_[0]." if ($_[0] !~ /^\d+$/o);
		  0;
	    } ],
	'MAX_NUMBER_OF_SIGNATURES_PER_KEY' => [
	    '1000',
	    sub { return "Expecting an integer value instead of $_[0]." if ($_[0] !~ /^\d+$/o);
		  0;
	    } ],
	'MAX_NUMBER_OF_NEW_SIGNATURES_PER_KEY' => [
	    '100',
	    sub { return "Expecting an integer value instead of $_[0]." if ($_[0] !~ /^\d+$/o);
		  0;
	    } ],
	'KEY_SPECIFIC_SIGNATURE_LIMITS' => [
	    [],
	    sub {
		my $type;
		my $row;
		if (ref($_[0]) ne 'ARRAY') {
		    my $type = (ref($_[0]) ? "a " . ref($_[0]) . " reference" : $_[0]);
		    return "Expecting an array of key signature limit definitions, now $type given.";
		}
		for $row (@{$_[0]}) {
		    return "Invalid key signature limit specification \"$row\"." if ($row !~ /^[a-f\d]{16}\s+\d+\s+\d+$/io);
		}
		0;
	    } ],
	);

    my %K = (
	'showconf' => \&show_configuration,
	'showconfig' => \&show_configuration,
	'siginfo' => \&show_sign_info,
	'refresh' => \&update_key_ring,
	'help' => undef, # Leave as undef, function usage already covers this.
	);
    my $command;
    my ($option, $optname);
    my $C = { map { $_ => $B{$_}[0] } keys %B };
    my $NC;
    my $prevhandler;
    my $tempstr;

    # We record the time stamp as early on as possible to count an as accurate
    # duration as possible when a refresh is run.
    $opts{'starttimestamp'} = time();
    
    # A hack.
    $command = $0;
    $command =~ s#^(?:.*/)?([^/]+)$#$1#g;
    $opts{'thecommand'} = $command;

    # Sigh ... getopt doesn't provide any error msg when an option is missing
    # its obligatory parameter ... but it returns 0.
    $prevhandler = $SIG{__WARN__};
    $SIG{__WARN__} = sub { };
    if (!getopts('c:Hg:w:s:r:k:f:h',\%opts)) {
	$SIG{__WARN__} = $prevhandler;
	&outputmsg_and_exit("Unknown option or failed to parse options.", 32);
    }
    $SIG{__WARN__} = $prevhandler;
    
    &outputmsg_and_exit(&usage($opts{'thecommand'}), 0) if ($opts{'h'});

    # We try to do this first thing so that we can initiate the logger
    # (Log::Log4perl) as early on as possible.
    if (defined $opts{'c'}) {
	($NC, $status) = &read_config_file($opts{'c'}, \%B);
	&outputmsg_and_exit($NC, $status) if ($status);
	# copy new values from NC over to C, i.e. defs from conf file
	# override hard-coded ones.
	while (my ($key, $value) = each %{$NC}) {
	    $C->{$key} = $value;
	}
    }

    # Mapping some options (if given) to conf parameters.
    while (($option,$optname) = each %opttoconfmap) {
	if (defined $opts{$option}) {
	    $C->{$optname} = $opts{$option};
	    $opts{'cli_options_given'} = 1;
	}
    }
    
    # Now, check the overall config (i.e. possible conf file + hard-coded confs)
    ($msg, $status) = &check_configs($C, \%B);
    &outputmsg_and_exit($msg, $status) if ($status);

    $tempstr = $C->{'FILELOGGERCONF'};
    Log::Log4perl->init(\$tempstr);

    # Were we given a valid command?
    &outputmsg_and_exit("Wrong number of commands (" . scalar(@ARGV) . ").", 33)
	if (@ARGV != 1);
    
    $command = $ARGV[0];
    &outputmsg_and_exit("Unknown command $command given.", 34)
	if (!exists $K{$command});

    # Piggy-backing
    $opts{'command'} = $command;

    # help as a command
    &outputmsg_and_exit(&usage($opts{'thecommand'}), 0) if ($command eq "help");

    &outputmsg_and_exit("Either option -c or -H must be given for a refresh.", 35)
	if (((!defined $opts{'c'}) and (!defined $opts{'H'})
	     or ((defined $opts{'c'}) and (defined $opts{'H'})))
	    and ($command eq "refresh"));

    # Check we have the auxiliary executables available
    my @missing = &ensure_we_have_aux_executables(\%preaux, \%aux);
    if (@missing) {
        print STDERR "Required executable(s) missing, install them and/or fix PATH:\n";
        for my $execs (@missing) {
             print STDERR "  $execs\n";
        }
        &outputmsg_and_exit(undef, 22);
    }
    
    # Run the desired operation
    ($msg, $status) = &{$K{$command}}($C, \%aux, \%opts);

    &outputmsg_and_exit($msg, $status);
}

&main;

exit(0);
